\section{Motivation}

\section{Approach}

\begin{algorithm}

\end{algorithm}


\section{Evaluation}

\begin{itemize}
    \item RQ1: To what extent developers agree with our approach result for getting overview of a project?
    \item RQ2: How helpful our approach to understand relevant high-level concepts targeting a low-level source code?
\end{itemize}

\section{Human-subject Study}
To evaluate the effectiveness of HCPC, we contacted with \emph{scidatamanager} development team. We have collected their source code to analyze by our system. We have invited the developers of the \emph{scidatamanager} project to validate whether HCPC can be helpful for getting overview of the \emph{scidatamanager} and accomplish a specific software maintenance task.
\subsection{Study Design}
The interview with developers are conducted remotely via Skype. The interview process was divided into four steps:
\begin{itemize}
    \item \emph{Introduction:} First, we brief each participants about our research. Then, we share our screen to show how to use HCPC tool. We demonstrate HCPC tool by exploring \emph{jupyter-client} project. We also discuss different components role to help program comprehension. Later, we asked the participants to go to a specific URL where our application is hosted and share their screen. We informed participants about two parts of the study.   
    \item \emph{Feedback on getting overview (RQ1):} In this phase, we asked the participants to explore the Cluster tree alongside different components like Node summary, Execution patterns. We requested them to check whether they can get overview of the \emph{scidatamanager} project. We encouraged the participants to express their thought while they explore different parts of the system. At the same time, we observe the participants interaction with the system and noted any feedback provided by them. When they explored the tree, we asked them whether the keywords and groups provide any reasonable clue about what the system does. Similarly, we asked them about their opinion on Node summary and Execution Patterns. We also inquired whether they have any suggestion or expectation on the components to be more helpful.
    
    
    \item \emph{Effectiveness of finding help for specific task (RQ2):} After we complete the second step, we move on to the third phase. In this step, we asked the participants to use the search option to find relevant nodes in the cluster tree and see whether they can find any help to do any specific task. We have encouraged them to remember any recent feature or issue they solved and try to see whether the HCPC tool could help them for completing the tasks. We asked the participants about how helpful Node summary, Execution patterns and the highlight of execution paths can be for someone new to the codebase to accomplish the tasks.
    \item \emph{Open discussion and closing:} At the end, we asked some open-ended questions about any suggestion and future features. The meetings lasted between 40 to 60 minutes. We ended the meeting thanking the participants for their valuable feedback and time.

\end{itemize}
\subsection{Participants and Subject System Selection}
While observing the HCPC tool output for \emph{jupyter-client} project, we can relate the different nodes content to the components in \emph{jupyter-client} documentation. We decided to conduct the study on a subject system where the team members can participate in the study to evaluate HCPC tool performance on their known codebase. We contacted the \emph{scidatamanager} team whether they could share their source code and participate in the study to evaluate HCPC. The development team of the \emph{scidatamanager} project agreed to share the codebase and participate in the study. 
\subsection{Results}
\textbf{Answering RQ1.} Participants mostly agreed that the HCPC tool can help getting overview of their project. When we asked the participants, they started to explore the abstraction tree by carefully observing the keywords for each node and expanding to child nodes. The participants agreed that high-level nodes provide hint to the features in their project. For example, participant P3 said, \emph{``I can relate to different basic components from high level nodes. If someone new joins the team, they can start from top nodes and see the path patterns for getting most frequent behaviour and then explore the code-base easily."} Participants appreciated the node summary as it states in plain text what are the purposes of the keywords in the project. Participants also find that when they see node summary for deeper nodes, the summary becomes more precise for specific features. 
According to participant P1, \emph{`` This part is helpful as it states in natural texts instead of a few words. Another interesting fact about the summary is when going deeper the summary became more precise.''} While exploring the execution patterns, we observed that participants find it helpful to know some frequent call sequences in specific nodes. However, participant P2, P3 suggested that having the frequency with the patterns would be interesting to know for understanding the importance. 

In summary, \textbf{Participants find HCPC tool helpful for getting overview of their software system with node title, summary and execution patterns.} According to their final feedback for comprehending overview, they pointed out that HCPC tool has the potential to decrease get started time for a project. According to participant P1, they believe  it can help to decrease getting started time around 50\%-60\%.

\textbf{Answering RQ2.} Participants find it useful to be able to search for specific keywords. From the interview, we observed that developers tried to highlight nodes for some recent work they have done or something they are familiar with to check how the HCPC is representing the relevant concepts. For example, participant P3 tried to highlight the nodes related to dataset publishing as it is one of the core feature of the project. While browsing the highlighted nodes and its supporting contents (node summary, execution patterns, execution paths), participant P3 identified that it is possible to know similar paths where the function is called. Another interesting observation by participant P2 is, \emph{`` I see the nodes can be searched by functions. In addition, I would love to see filters such as class, files.''} Participant P3 shared from their previous experience that sometimes they have to fix some issues of another project which not very well documented and they struggle a lot to figure out the abstraction patterns followed in the codebase. Both participant P3, P1 suggested using the search option to explore execution paths will be helpful to decrease time required for completing tasks in those scenarios. Another interesting observation from the interview is for some searches multiple nodes are highlighted which shows the specific functions being used in different scenarios. We observed participants was enthusiastic to know what are the different directions the function is being used by going deeper in the abstraction tree. In addition, participant P1 shared that many times they try to search the codebase with some keywords using the find option provided by the editor to retrieve relevant files. However, the search result does not show any order or how these class or methods are being called. They suggested that with the execution patterns and paths HCPC can help replacing the raw find workflow into more execution based search process. In summary, \textbf{the feedback from the participants and our observation during the interview it is viable that the search option of  HCPC has the potential to help in day-to-day software maintenance activities. } 

% To Do using find button for searching which do not have any order

During our open-ended questions and suggestions, we found valuable feedback for future development and adaptation of the HCPC tool. One important suggestion is to incorporate automatic comment generation techniques for methods which have no comments. This will be a valuable future work suggestion for our HCPC tool, as it will be helpful for projects which do not follow best practices. Another worth mentioning future work is suggested by participant P2 is to generate report of the abstraction structure where developers can edit the components name according to their understanding from the HCPC tool. These report can be used as a documentation of the project structure from static execution perspective. In addition, participants suggested to enable the option to export projects from GitHub which will be useful for quickly exploring a new codebase. From the above discussion, \textbf{we can conclude that HCPC tool can help to get overview of a software project from static execution perspective and can be used to help doing a specific task in hand.}


% TODO
% github, report generation 


\subsection{Threats to validity}



\section{Implementation }
In this section, we briefly highlight different parts of our implementation as shown in Figure \ref{fig:architecture}.

\begin{enumerate}
    \item We clone the source code from GitHub in a temporary folder. The source code will be used in the next phase by Python static code analyzer.
    \item We use Pyan~\cite{pyan} as static Python code analyzer. Pyan goes through all the \emph{*.py} files looking for which method calls which method. Pyan generates a text file  which encodes all the methods with numbers and then contains which method calls which method. We generate static call graph using NetworkX~\cite{networkx} with the caller-callee relationships generated by Pyan.
    
\begin{figure*}[h]
\centering
\includegraphics[width=\columnwidth]{figures/hla3/hla3_implementation.png}
\caption{Architecture of HCPC tool }~\label{fig:architecture}
\end{figure*}

    \item We generate execution paths from the call graph created in previous step.
Execution paths are grouped using Agglomerative Hierarchical Clustering~(AHC) algorithm provided by Scipy~\cite{scipy} library with \emph{ward} method as distance metric. We have a binary tree structure where leaf nodes are execution paths and other nodes are clusters at different levels. We call these cluster nodes as abstraction nodes. The abstraction nodes have collection of execution paths. For each abstraction node, we generate three properties. For each node, we create node title by applying information retrieval techniques ( Scikit-learn~\cite{scikit-learn} for TFIDF and Gensim~\cite{gensim} for LDA, LSI ) on the method names of all execution paths of a node. Then we produce node summary by summarizing (TextRank by Gensim) method comments of all the execution paths of the node. Last we generate execution patterns by pattern mining among the execution paths of the node~(PrefixSpan \cite{prefixspan}). We write all the node data in a text file named with the project name. Data is written in JSON format where each node is keyed with their ID and they have parent\_id, node title, node summary, execution patterns and execution paths associated with them. 
    \item We have Flask server for interacting with front-end. Client requests which subject system they want to explore and the server returns JSON response with the abstraction tree. 
    \item For the interface of our web application, we have used HTML, CSS, and JQuery. When a specific node is right-clicked, detail information about the node is filled to the node details panel.
    \item We used GoJS for building the abstraction tree diagram. Each abstraction  is a GoJS node and different properties of the abstraction nodes are binded to GoJS nodes. 

\end{enumerate}


\section{Interface}

In this section, we will discuss the different components of our HCPC tool shown in Figure \ref{fig:interface}.

\begin{itemize}
    \item \textbf{Abstract Tree Panel(A).} In the panel, the main abstraction tree is presented. The root nodes are presented vertically which can be possible to expand with their child nodes. By right clicking the mouse on a node will load different information of the abstraction node in the right side of the interface.
    \item \textbf{Number of execution paths(B).} As each node in the abstraction tree are a collection of execution paths, we show the number of execution paths for a selected node in this element.
    \item \textbf{Files (C).} In the element, we show the unique files of all the methods of the execution paths belong to.
    \item \textbf{Node summary (D).} In the element, we have provided natural text description of a node. When developers select a node, the text description of the node will appear in the element. 
    \item \textbf{Execution Patterns (E).} In the element, for a selected abstraction node, frequent function call patterns are presented with the file they are associated with. In the current setting, top-10 frequent execution patterns are shown. 
    
    \item \textbf{Execution paths (F).} In the element, we show five execution paths of a selected abstraction node. The execution paths complement the execution patterns by showing a glimpse of the real execution paths. Moreover, when a specific method is searched, the execution paths with the searched method is presented instead first five methods.
    
    \item \textbf{ Node label technique and search panel (G).} The panel has three drop-down boxes. First, developers can select which subject system they want to explore. Second, they can choose which technique to be used for labeling the nodes in abstraction tree. Third, this drop-down box is search enabled and it helps to highlight the nodes which have the searched method in their execution paths.
\end{itemize}

\begin{figure*}[h]
  \centering
  \includegraphics[width=\columnwidth]{figures/hla3/hla3_interface.png}
  \caption{HCPC tool interface }~\label{fig:interface}
\end{figure*}


\section{Guide to use HCPC}
The tool can be used in two ways. First, a developer new to the code-base can load the abstraction tree which start with the root node. In the right side panel, for each node the number of execution paths, a brief natural text summary, and few frequent execution patterns are presented. Therefore, the developer can start first by observing summary, patterns of the root node. Now, the child nodes of the root node can be expanded and  similarly explored by observing corresponding node summary and patterns. The developer can continue this way according to their need to get acquainted with the coda-base behavior and high-level concepts in the code-base.

Second, a new contributor to a open source project can utilize the tool to understand high-level concepts related to a specific method. Developers first start from looking to open issues of a repository to find something work on. The issues are natural text description which provides information regarding a bug or a feature enhancement request. Developers can identify few keywords and use our tool to find matching methods relevant to the keywords. Next, a specific method can be selected to highlight relevant nodes in the tree. The difference between the first approach here is developers will be able to browse the tree with focus to the selected method. The node titles relevant to selected method will be highlighted so that the developer can expand their child nodes. By this way, the developer can start from the high-level concept to low-level source code related concepts for a specific method. By iterating this process, the developer can grasp high-level domain knowledge (with comment summary and IR techniques on function names) alongside insight into program execution scenarios which decreases the overhead due to lack of domain knowledge in the code-base. 

\section{Graphical demo of the tool} 
We have picked \emph{jupyter-client}\footnote{https://github.com/jupyter/jupyter\_client} as the subject system to show how the tool can be used following the two above mentioned techniques. To discuss the effectiveness of our tool using \emph{jupyter-client}, first we will discuss high level functionalities of \emph{jupyter-client} from their documentation. Later, we will present the information provided by our tool and discuss whether our tool provides similar or more information to comprehend the \emph{jupyter-client} project. \emph{jupyter-client} has three components. First, \emph{kernelspec} deals with specify different type of kernels from predefined files. Second, kernel manager which is responsible for start, stop and signaling kernels for different scenarios. Third, kernel client which is responsible for communicating with kernels for code execution and other tasks \footnote{https://jupyter-client.readthedocs.io/en/stable/index.html}. From the above components we can get an abstract idea of the features of \emph{jupyter-client}. Now, we will discuss the high-level features suggested by HCPC tool. Below we have listed few high-level features of the \emph{jupyter-client} project. The features are found by expanding the tree to three depth. More specific features are possible to get by diving deep into the tree.

\begin{figure*}[h]
  \centering
  \includegraphics[width=\columnwidth]{figures/hla3/tool_overview_jupyter.png}
  \caption{HCPC tool overview for jupyter\_client project }~\label{fig:tool_overview_jupyter_client}
\end{figure*}

\begin{itemize}
    \item Request kernel info. Request comm info. Tab complete text in the kernel's namespace. Get metadata information about an object in the kernel's namespace. Ask the kernel whether some code is complete and ready to execute.
    \item Forgets randomly assigned port numbers and cleans up the connection file. Restarts a kernel with the arguments that were used to launch it. Write connection info to JSON dict in self.connection\_file. Restarts a kernel with the arguments that were used to launch it.
    \item Request kernel info. Given a message or header, return the header. Request comm info. Tab complete text in the kernel's namespace. wrapper for doing common steps for validating an execution request. Pass a message to the ZMQ socket to send. message format.
    \item Send a shutdown request via control channel. Attempts to stop the kernel process cleanly. Restarts a kernel with the arguments that were used to launch it.
\end{itemize}

From the above text blocks, we can understand that \emph{jupyter-client} is relevant to working with kernels, it uses ZMQ socket to communicate with kernels, and work with kernel information. 

Next, it is possible to browse the tree by focusing on a specific method. In figure \ref{fig:tool_shutdown_all}, we can see the nodes in the tree are marked to indicate they are relevant to shutdown\_all method. Developers can investigate the nodes marked to understand relevant features of shutdown\_all method. 

\begin{figure*}[h]
  \centering
  \includegraphics[width=\columnwidth]{figures/hla3/tool_shutdown_all.png}
  \caption{HCPC tool when focusing to find features related to shutdown\_all method }~\label{fig:tool_shutdown_all}
\end{figure*}


\begin{itemize}
    \item check that a kernel id is valid. Interrupts the kernel by sending it a signal. Wait for kernel shutdown, then kill process if it doesn't shutdown. Shutdown all kernels. Sends a signal to the process group of the kernel (this. Restarts a kernel with the arguments that were used to launch it. Attempts to stop the kernel process cleanly. Get the single KernelManager object for a kernel by its uuid.
    \item Get the hb channel object for this kernel. Get the stdin channel object for this kernel. Stops all the running channels for this kernel. Get the iopub channel object for this kernel. Get the control channel object for this kernel. Get the shell channel object for this kernel.
    
\end{itemize}

From above information provided by the tool, we can know how the shutdown\_all method works. Also we know that kernel object has different kind of channels for communication such as iopub, stdin.  

\section{Conclusion}
