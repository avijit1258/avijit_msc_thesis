In this chapter, we provide a brief description of the thesis. In Section \ref{intro:motivation}, we discuss motivation of the thesis. Then we addressed three problems in Section \ref{intro:problem}. In Section \ref{intro:research_questions} and \ref{intro:solution}, we have introduced the research questions and provided brief summary of our solutions. In Section \ref{intro:outline}, we outline the whole thesis chapters. 


\section{Motivation}
\label{intro:motivation}
 The growing complexity of software applications requires large codebase. As the life-cycle of a software increases, more resources are devoted to the maintenance of the software. If some developer wants to add a new feature or fix bugs in existing features, they need to understand related domain knowledge alongside relevant code structure. The ratio of reading code versus writing code in a software developers role is over 10 to 1 \cite{martin2008clean}. In addition, if a new developer joins the team, they need to understand how the high-level feature maps with existing low-level source code. When a software developer has to implement a new feature or enhance an existing feature, they need to look for the relevant files, classes to understand how different part of the relevant code interacts. After getting a good grasp on the relevant codebase, the developer can start working on the new feature. The process of looking for relevant codebase to fix a bug or implement a new feature is called concept location. Existing techniques for concept location focus on keyword based searching in the codebase. Code search engines return relevant files, classes when developers search for particular keywords. 
 
 However, the program comprehension techniques mainly consist of two models \cite{tilley1998reverseEngineeringFramework, von1993programToolRequirements, siegmund2016programPastFuture}. One is the top-down model where developers have the domain knowledge of the system and tries to map bottom-level source code to the high-level domain knowledge. In many cases, the developers lack the domain knowledge which force them to go through low-level codebase and gradually build the high-level knowledge. The process of cognitive mapping from source code to domain knowledge is called bottom-up model. When the codebase is new or unknown to the developer and developers lack domain knowledge, generally bottom-up model is followed by the developers. The top-down model is more flexible and efficient as developers have some idea what to expect in the codebase or where to start from. 
 
 As program comprehension is an integral part for software maintenance, better tool support for program comprehension will help developers do their day-to-day job faster. Better tool support for program comprehension can save valuable human resource which cut the overall cost of a software maintenance. Developers prefer to have high-level domain knowledge and then map the source code to the domain knowledge \cite{brooks1983theoryComprehensionPrograms}. To reduce the dependence on bottom-up model, researchers work on building hierarchical abstraction which simulate the process of bottom-up model. Finally, providing a tree like structure where high-level concepts in the software systems are presented by grouping topics in low-level source code. 


In the source code, method names are the lowest level abstraction. The method names represent a single unit task of the overall system \cite{de2012using, starke2009searching}. The interaction between different methods are the building blocks to understand high-level concept in source code. Call graphs are visual representation of interaction between methods in the system. Call graphs construction methods are two types. The static call graphs are built by analyzing source code to find the caller-callee relationships between different methods. Later, building a graph using the relationships where edges represent which method calls which method and nodes represent the method names. Another type of call graph is dynamic call graph. The dynamic call graphs are constructed by logging function invocation sequences during the run-time. To generate dynamic call graph, the software system needs to be run for different scenarios. During the scenario execution, function invocations are recorded which can be converted to a graph similar to the static call graph. The main difference between dynamic call graph and static call graph is that the dynamic call graph contains the only methods invoked during the execution where the static call graph contains all the methods in the codebase \cite{gharibi2018automaticStaticCluster}. The advantage of dynamic call graph is that the call graph can be generated for a targeted execution scenarios \cite{feng2018hierarchicalExecutionComprehension}. However, as we want to create a tool for supporting program comprehension models, including all possible scenarios is very crucial. One more disadvantages of dynamic call graph is that it generates huge redundant data which is difficult to process. 

As the static call graph properties align more with the goal of building hierarchical abstraction of a software system, recently few research is going on using static call graph to generate abstraction of a software system \cite{gharibi2018automaticStaticCluster, walunj2019graphevoEvolutionCall}. In this thesis, we focus on improving the existing research findings with more sophisticated techniques. We also focus on the usability of the hierarchical abstraction by building an interactive system which helps developers to navigate the abstraction in a guided way according to their specific task. 

 
\newpage


\section{Problem }
\label{intro:problem}
% In this section, we state three sub-problems addressed in this thesis.
    \subsection{Sub-Problem \#1: Lack of human evaluation and comparison between IR techniques} In the literature, a great many studies have been performed to generate hierarchical abstraction of a software system using both static and dynamic call graph \cite{feng2018hierarchicalExecutionComprehension, gharibi2018automaticStaticCluster, xin2019identifyingFeaturesExecution}. The hierarchical abstraction is a tree like structure where execution scenarios are clustered and each node is labeled using different IR techniques on source code entities. The success of the abstraction tree depends on how well the labeling techniques perform. Different information retrieval techniques show promise in naming source code artifacts \cite{chen2016topicMiningRepositories, panichella2013topicModelsTasks, sun2016surveyTopicSE}. Although a lot of work exist on hierarchical abstraction, they lack comprehensive study on the effectiveness of different information retrieval techniques in labeling nodes of an abstraction tree with human in the loop. Moreover, methods are treated as a unit [cite] while using different information retrieval techniques for labeling nodes. Previous research [cite] show that IR techniques perform better when more information like comments are used instead of method names. Therefore, using method names as unit provides less opportunity to retrieve the overall context.
    

    \subsection{Sub-Problem \#2: Abstraction nodes are too short for useful comprehension}
    In the previous studies \cite{feng2018hierarchicalExecutionComprehension, gharibi2018automaticStaticCluster}, nodes in the hierarchical abstraction tree have only few keywords extracted from method signatures. During our first study to evaluate IR techniques on labeling nodes, we observed that using 5-10 method names or words serves the purpose as a title for the node. The title can provide some context although it is difficult to comprehend what is happening inside a node without further detail. The content inside a node are execution paths which can be of variable length with many in quantity. Providing all the execution paths of a node to developers hinders the purpose of abstraction in nodes. Therefore, the challenge is to come up with a solution which can briefly provide context of a node without providing everything. 
    
   

    \subsection{Sub-Problem \#3: Making the abstraction tree usable for software engineering tasks} 
    
    New comers to open source software struggle with lack of domain knowledge. Usually developers look for trending projects in their choice of language to contribute. As most of the time the problem being solved is unknown to the contributor, developers struggle to map low-level source code to high-level concepts. As it is stated in previous studies [cite], developers prefer Top-down model to browser source code for program comprehension. In top-down model developers have some domain knowledge, which they later try to map with source code. The hierarchical abstraction tree have the potential to bridge gap between top-down and bottom-up cognition model. However, the challenge is how to tailor the abstraction tree for the developers to use for a specific task in hand or targeting a specific unit of source code (method). 
    
    % Hierarchical abstraction tree help developers to understand high-level domain knowledge. When developers have domain knowledge, they tend to follow top-down model. As the abstraction tree captures high-level summary of whole software system, it is difficult to browse the abstraction tree for a specific task in hand. Browsing the abstraction tree by a guided way driven by task in hand can make the tree more usable in software maintenance. 
    
\section{Research Questions}   
\label{intro:research_questions}
While considering the above problems discussed in Section \ref{intro:problem}, we came up with below mentioned five research questions.
\begin{itemize}
    \item RQ1: How well the automatic labeling with the candidate approaches perform compared to manual labeling?
    \item RQ2: What are the developers preferences between method name versus words in method name variation of labeling techniques?
    \item RQ3: How can we provide a natural text summary to an abstraction nodes?
    \item RQ4: How can we provide significant patterns in execution paths for each abstraction node?
    \item RQ5: How can we make the abstraction tree useful for daily day-to-day software engineering jobs?
    
\end{itemize}

Research question one and two correspond to \emph{sub-problem 1}, research question three and four correspond to \emph{sub-problem 2} and research question five correspond to \emph{sub-problem 3}. The main goal of this research is to help developers during program comprehension activities. 



\section{Solution}
\label{intro:solution}
Considering the three above mentioned problem statements (Section \ref{intro:problem}) in the domain of program comprehension, we contributed three studies. Below we have briefly discussed the three studies.  

\subsection{Labeling abstraction nodes and human evaluation}

In this study, by mining concepts from source code entities (names of functions/methods), we generate a concept cluster tree
with improved naming of the cluster nodes to complement existing studies to facilitate more effective program comprehension for
developers to address \emph{problem statement \#1}. We apply three different information retrieval techniques such as TFIDF, LDA, and LSI (i.e., each technique with function
names and words in function names variation) to name nodes of concept cluster tree generated by clustering execution paths. Our experiment found that among the techniques on average, TFIDF performs better with around 64\% matching than the other
two methods (LDA and LSI) that report 37\% and 23\% matching respectively with names suggested by the users for 12 cases. Besides,
the words in function name variant perform at least 5\% better in user rating for all the three techniques on average for the use cases.
Our study draws on the existing research but considers more techniques and humans response for comprehending outputs using the three
techniques.

\subsection{Providing summary and significant patterns for abstraction nodes}

In this study, we develop two new techniques to make nodes in hierarchical abstraction tree more understandable to address \emph{sub-problem \#2}. Generally methods are expected to come with documentation at the start with a single line describing what the function does unless the method is very short and obvious \footnote{https://google.github.io/styleguide/pyguide.html}. First, We tried to exploit this common practice for generating brief text summary for each node. 
To complement existing techniques of labeling nodes, we add a text description to the node by summarizing all the method comments under that node. 

Second, execution paths in the call graph represent execution scenarios~\cite{salah2005scenariographer,pradel2009automatic}. Therefore, inspired by previous studies [cite] we add significant patterns for each node by analyzing all execution paths under the node. We conduct an empirical study with three subject systems to evaluate the potential of the two proposed techniques. We found that proposed techniques complement existing abstraction tree although there are some challenges. By addressing those challenges, the proposed techniques will be more effective for program comprehension. 


\subsection{Usability study of hierarchical abstraction tree}
As discussed in the \emph{sub-problem #3}, making the abstraction tree browse-able with specific target is helpful for new contributors in open source software systems. Having system which helps top-down cognition possible without domain knowledge can be a game changer for new contributors. In this study, we have built a system where tree can be browsed by selecting a specific method or class. When a specific method or class is selected, relevant concepts in the tree are highlighted. Moreover, developers can see information like files involved, number of execution paths, summary and frequent patterns of a abstraction node. To evaluate the effectiveness, we have collected expert opinion regarding the usability of the system. 

% In this study, we built an interactive system which help developers use the abstraction tree in a guided way to address \emph{problem statement \#3}. When Developers search with keywords in the tree, the system highlight the relevant nodes. So, the developers can browse the abstraction tree for specific task in hand. We conducted a user-study to evaluate the effectiveness of the system. 

% \section{Related Publications}

\section{Outline of the Thesis}
\label{intro:outline}

In Chapter \ref{chapter:background}, we discuss some background on call graph related terminology, clustering technique, different information retrieval techniques alongside one text summary technique. Chapter \ref{chapter:hla1} focuses on different information retrieval techniques with human evaluation. In Chapter \ref{chapter:hla2}, we proposed adding node summary and patterns in the abstraction tree to aid developers program comprehension. Finally, in Chapter \ref{chapter:conclusion} we conclude the overall summary of the thesis and discuss some future plan. 
