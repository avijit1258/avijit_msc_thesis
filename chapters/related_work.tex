In this chapter, we discuss relevant literature in regard to program comprehension, reverse engineering and feature location. In Section \ref{related:program_comprehension}, we discuss scope of program comprehension from literature. We then present how different IR techniques used for naming source code artifacts in Section \ref{related:IR}. Last, in Section \ref{related:reverse_engineering} and \ref{related:feature_locate}, we explained different reverse engineering techniques and how developers locate features.


\section{Program Comprehension in general}
\label{related:program_comprehension}
Program comprehension is a cognitive way of understanding software systems to perform different software maintenance tasks \cite{wei2002surveyCategorizationComprehension, siegmund2016programPastFuture}. Three different type of cognitive models \cite{tilley1998reverseEngineeringFramework, von1993programToolRequirements, siegmund2016programPastFuture} can be found in the literature which is followed consciously or unconsciously by developers. The comprehension models are Top-down, Bottom-up, and Integrated. When developers have prior domain knowledge about a software system, the top-down model is preferred as they can map domain knowledge to low-level source code hierarchically \cite{brooks1983theoryComprehensionPrograms}. On the other hand, when developers lack domain knowledge, they start with low-level source code and then group the functionality together to have a hierarchical abstraction of the system features \cite{shneiderman1979syntacticInteractionsModel, pennington1987stimulusMentalRepresentations}. Integrated model \cite{shaft1995relevanceDomainKnowledge, von1993programToolRequirements} is a mix of top-down and bottom-up approach. The problem in hand and the target system have different properties in the real world, which demand switching between top-down and bottom-up models. Generally, a developer can have prior domain knowledge of a few portion and point-blank for the rest of the system. This situation deserves the adapted use of both top-down and bottom-up approaches.   


\section{IR techniques to Name source code artifacts}
\label{related:IR}
% \cite{mcburney2014improvingTopicSummarize}
% \cite{de2012IRMethodsArtifacts} \cite{panichella2013topicModelsTasks}
% \cite{chen2016topicMiningRepositories}
% Very very important \cite{sun2016surveyTopicSE}
As software repositories contain unstructured data, topic model techniques are widely applied for different software engineering tasks to retrieve information \cite{chen2016topicMiningRepositories, panichella2013topicModelsTasks, sun2016surveyTopicSE}. Most common tasks where topic models showed promising results are source code comprehension, feature location, refactoring, bug localization, and others \cite{sun2016surveyTopicSE}. Lucia et al. \cite{de2012IRMethodsArtifacts} conducted a study to see how information retrieval techniques perform compared to manual naming Java class files. Developers were asked to pick ten keywords for each class file, and top-10 words are picked using different topic model technique and custom heuristics. Their experiment shows that in 40\%-80\% cases, automatic and human label overlaps. 

\section{Reverse Engineering}
\label{related:reverse_engineering}
\subsection{Subsystem Identification}
Muller et al. \cite{muller1990composingSubsystemStructures} proposed subsystem detection algorithm using different clustering components like variable, procedure, and modules. 
According to Bass et al. \cite{bass2003softwareArchitecturePractice}, two types of software architecture are useful for understanding a complex software system. They are Conceptual and Concrete architecture. A conceptual architecture provides high-level abstraction skipping the code level details. On the other hand, concrete architecture shows the implementation level information. Roy et al. \cite{roy2008softwareArchitectureRecovery} propose and evaluate a framework for the incremental and iterative application of automated architecture recovery (using SWAG Kit) and architecture analysis (using SAAM.). They showed that the reverse engineering tool cannot recover a deeply understood conceptual architecture without SAAM's application but can create a reasonable basis towards that direction. Murphy et al.\cite{MurphyNotkin2001} show that by generating reflexion models from high-level model and source model (i.e., static call graphs), it is possible to facilitate program understanding to the novice developers. 

In this study, we try to automatically recover conceptual architecture from concrete architecture, reducing manual effort.

\subsection{Call graphs to abstract a software system behaviors}

Static and dynamic call graphs are used in literature to help developers comprehend a software system to aid different maintenance tasks \cite{feng2018hierarchicalExecutionComprehension, gharibi2018automaticStaticCluster, xin2019identifyingFeaturesExecution}. Feng et al. \cite{feng2018hierarchicalExecutionComprehension} proposed an approach to use dynamic call graphs for understanding a system's behavior. They instrumented the subject systems to generate execution traces of method entry and exit events. Later, they followed the duplication removal process and constructed a call graph from the execution traces. Execution phases from this dynamic call graph are clustered to get system behaviors. Similarly, Gharib et al. \cite{gharibi2018automaticStaticCluster}, and Vijay et al. \cite{walunj2019graphevoEvolutionCall} also adopted clustering of execution paths from call graphs of the static variant. Using a static call graph brings the benefit of capturing all possible scenarios and less redundant data to handle than dynamic call graph \cite{gharibi2018automaticStaticCluster}. 

\subsection{IR techniques on the hierarchical abstraction of software system}
Feng et al. \cite{feng2018hierarchicalExecutionComprehension} proposed an approach to identify behaviors of a system by hierarchically abstracting dynamic call graph from execution traces. Sequential pattern mining is applied to mine significant portions from the execution phases. Hierarchical clustering is performed to group execution phases. Later, the clusters are labeled using the TFIDF score, where method signatures serve as terms and the phases as document. 
Paul et al. \cite{mcburney2014improvingTopicSummarize} used static call graph to hierarchically abstract a system. In their hierarchical view, each node represents a method. To mine the topics, keywords from methods are considered. Hierarchical Document Topic Model (HDTM) by \cite{weninger2012documentTopicHierarchies} Weninger et al. is adopted, which works on graph documents to mine topic. Gharib et al. \cite{gharibi2018automaticStaticCluster} took a different approach. They went further with the static call graph by extracting execution paths and then clustering the execution paths. Each cluster in the cluster tree is labeled using top-5 method names from Tfidf. Levy et al. \cite{levy2019understandingLargeHierarchical} found interviewing developers that two kinds of comprehension go for large scale hierarchical view. They are system comprehension and code comprehension. In this paper, we tried to adopt static call graph analysis from Gharib et al. and then improve their labeling technique. Nodes of the cluster tree is considered as a behavioral abstraction unit of a system. Method comments are used to generate a description of the unit and sequential pattern mining to create sample examples. 

\section{How developers locate feature on source code}
\label{related:feature_locate}
Kruger et al.~\cite{kruger2019features} studied on two data sets (67 developers IDE activity, 600 developers IR-based tool usage). They suggested that there is room for improvement in the existing code navigation, code search tools. The manual process followed by developers to locate feature are of mostly three types ~\cite{damevski2016field, wang2011exploratory, revelle2005understanding}. First, developers use information retrieval based tools to query for feature related keywords. In this thesis, we have used IR based techniques to label nodes. Developers can use our tool to find keywords of their interest. Second, execution-based process where developer try to find execution scenarios where the feature is active. After finding relevant execution scenarios, developers debug the execution scenarios by setting breakpoints. In our second study, we have attached execution patterns to nodes which can be utilized by developers to know where to set the breakpoints for understanding a feature. Third, exploration based process where developer explore source code to understand method calls to find a feature. In HCPC tool, we showed method execution patterns for each node. Our tool can also help developers for browsing code using exploration based process.
% Include this paper and its related works. \cite{damevski2016field} \cite{kruger2019features} see 5.5.4 process section 